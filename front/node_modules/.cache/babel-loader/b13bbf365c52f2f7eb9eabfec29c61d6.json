{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar util = require('util'),\n    actions = require('../context/http/actions'),\n    Context = require('../context/http/context');\n/**\n * Authenticates requests.\n *\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\n * order to authenticate the request.  If authentication is successful, the user\n * will be logged in and populated at `req.user` and a session will be\n * established by default.  If authentication fails, an unauthorized response\n * will be sent.\n *\n * Options:\n *   - `session`          Save login state in session, defaults to _true_\n *   - `successRedirect`  After successful login, redirect to given URL\n *   - `failureRedirect`  After failed login, redirect to given URL\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\n *\n * An optional `callback` can be supplied to allow the application to overrride\n * the default manner in which authentication attempts are handled.  The\n * callback has the following signature, where `user` will be set to the\n * authenticated user on a successful authentication attempt, or `false`\n * otherwise.  An optional `info` argument will be passed, containing additional\n * details provided by the strategy's verify callback.\n *\n *     app.get('/protected', function(req, res, next) {\n *       passport.authenticate('local', function(err, user, info) {\n *         if (err) { return next(err) }\n *         if (!user) { return res.redirect('/signin') }\n *         res.redirect('/account');\n *       })(req, res, next);\n *     });\n *\n * Note that if a callback is supplied, it becomes the application's\n * responsibility to log-in the user, establish a session, and otherwise perform\n * the desired operations.\n *\n * Examples:\n *\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\n *\n *     passport.authenticate('basic', { session: false });\n *\n *     passport.authenticate('twitter');\n *\n * @param {String} name\n * @param {Object} options\n * @param {Function} callback\n * @return {Function}\n * @api public\n */\n\n\nmodule.exports = function authenticate(name, options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {}; // Cast `name` to an array, allowing authentication to pass through a chain of\n  // strategies.  The first strategy to succeed, redirect, or error will halt\n  // the chain.  Authentication failures will proceed through each strategy in\n  // series, ultimately failing if all strategies fail.\n  //\n  // This is typically used on API endpoints to allow clients to authenticate\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\n  // It is not feasible to construct a chain of multiple strategies that involve\n  // redirection (for example both Facebook and Twitter), since the first one to\n  // redirect will halt the chain.\n\n  if (!Array.isArray(name)) {\n    name = [name];\n  }\n\n  return function authenticate(req, res, next) {\n    var passport = this; // accumulator for failures from each strategy in the chain\n\n    var failures = [];\n\n    function allFailed() {\n      if (callback) {\n        if (failures.length == 1) {\n          return callback(null, false, failures[0].challenge, failures[0].status);\n        } else {\n          var challenges = failures.map(function (f) {\n            return f.challenge;\n          });\n          var statuses = failures.map(function (f) {\n            return f.status;\n          });\n          return callback(null, false, challenges, statuses);\n        }\n      } // Strategies are ordered by priority.  For the purpose of flashing a\n      // message, the first failure will be displayed.\n\n\n      var failure = failures[0] || {},\n          challenge = failure.challenge || {};\n\n      if (options.failureFlash) {\n        var flash = options.failureFlash;\n\n        if (typeof flash == 'string') {\n          flash = {\n            type: 'error',\n            message: flash\n          };\n        }\n\n        flash.type = flash.type || 'error';\n        var type = flash.type || challenge.type || 'error';\n        var msg = flash.message || challenge.message || challenge;\n\n        if (typeof msg == 'string') {\n          req.flash(type, msg);\n        }\n      }\n\n      if (options.failureMessage) {\n        var msg = options.failureMessage;\n\n        if (typeof msg == 'boolean') {\n          msg = challenge.message || challenge;\n        }\n\n        if (typeof msg == 'string') {\n          req.session.messages = req.session.messages || [];\n          req.session.messages.push(msg);\n        }\n      }\n\n      if (options.failureRedirect) {\n        return res.redirect(options.failureRedirect);\n      } // When failure handling is not delegated to the application, the default\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\n      // header will be set according to the strategies in use (see\n      // actions#fail).  If multiple strategies failed, each of their challenges\n      // will be included in the response.\n\n\n      var rchallenge = [],\n          rstatus;\n\n      for (var j = 0, len = failures.length; j < len; j++) {\n        var failure = failures[j],\n            challenge = failure.challenge || {},\n            status = failure.status;\n\n        if (typeof challenge == 'number') {\n          status = challenge;\n          challenge = null;\n        }\n\n        rstatus = rstatus || status;\n\n        if (typeof challenge == 'string') {\n          rchallenge.push(challenge);\n        }\n      }\n\n      res.statusCode = rstatus || 401;\n\n      if (rchallenge.length) {\n        res.setHeader('WWW-Authenticate', rchallenge);\n      }\n\n      res.end('Unauthorized');\n    }\n\n    (function attempt(i) {\n      var delegate = {};\n\n      delegate.success = function (user, info) {\n        if (callback) {\n          return callback(null, user, info);\n        }\n\n        info = info || {};\n\n        if (options.successFlash) {\n          var flash = options.successFlash;\n\n          if (typeof flash == 'string') {\n            flash = {\n              type: 'success',\n              message: flash\n            };\n          }\n\n          flash.type = flash.type || 'success';\n          var type = flash.type || info.type || 'success';\n          var msg = flash.message || info.message || info;\n\n          if (typeof msg == 'string') {\n            req.flash(type, msg);\n          }\n        }\n\n        if (options.successMessage) {\n          var msg = options.successMessage;\n\n          if (typeof msg == 'boolean') {\n            msg = info.message || info;\n          }\n\n          if (typeof msg == 'string') {\n            req.session.messages = req.session.messages || [];\n            req.session.messages.push(msg);\n          }\n        }\n\n        if (options.assignProperty) {\n          req[options.assignProperty] = user;\n          return next();\n        }\n\n        req.logIn(user, options, function (err) {\n          if (err) {\n            return next(err);\n          }\n\n          if (options.authInfo || options.authInfo === undefined) {\n            passport.transformAuthInfo(info, function (err, tinfo) {\n              if (err) {\n                return next(err);\n              }\n\n              req.authInfo = tinfo;\n              complete();\n            });\n          } else {\n            complete();\n          }\n\n          function complete() {\n            if (options.successReturnToOrRedirect) {\n              var url = options.successReturnToOrRedirect;\n\n              if (req.session && req.session.returnTo) {\n                url = req.session.returnTo;\n                delete req.session.returnTo;\n              }\n\n              return res.redirect(url);\n            }\n\n            if (options.successRedirect) {\n              return res.redirect(options.successRedirect);\n            }\n\n            next();\n          }\n        });\n      };\n\n      delegate.fail = function (challenge, status) {\n        // push this failure into the accumulator and attempt authentication\n        // using the next strategy\n        failures.push({\n          challenge: challenge,\n          status: status\n        });\n        attempt(i + 1);\n      };\n\n      var layer = name[i]; // If no more strategies exist in the chain, authentication has failed.\n\n      if (!layer) {\n        return allFailed();\n      } // Get the strategy, which will be used as prototype from which to create\n      // a new instance.  Action functions will then be bound to the strategy\n      // within the context of the HTTP request/response pair.\n\n\n      var prototype = passport._strategy(layer);\n\n      if (!prototype) {\n        return next(new Error('no strategy registered under name: ' + layer));\n      }\n\n      var strategy = Object.create(prototype);\n      var context = new Context(delegate, req, res, next);\n      augment(strategy, actions, context);\n      strategy.authenticate(req, options);\n    })(0); // attempt\n\n  };\n};\n\nfunction augment(strategy, actions, ctx) {\n  for (var method in actions) {\n    strategy[method] = actions[method].bind(ctx);\n  }\n}","map":{"version":3,"sources":["/Users/fadimoughaizel/Desktop/Portfolio/Forum/forum/node_modules/passport/lib/passport/middleware/authenticate.js"],"names":["util","require","actions","Context","module","exports","authenticate","name","options","callback","Array","isArray","req","res","next","passport","failures","allFailed","length","challenge","status","challenges","map","f","statuses","failure","failureFlash","flash","type","message","msg","failureMessage","session","messages","push","failureRedirect","redirect","rchallenge","rstatus","j","len","statusCode","setHeader","end","attempt","i","delegate","success","user","info","successFlash","successMessage","assignProperty","logIn","err","authInfo","undefined","transformAuthInfo","tinfo","complete","successReturnToOrRedirect","url","returnTo","successRedirect","fail","layer","prototype","_strategy","Error","strategy","Object","create","context","augment","ctx","method","bind"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\nvar util = require('util')\n  , actions = require('../context/http/actions')\n  , Context = require('../context/http/context')\n\n\n/**\n * Authenticates requests.\n *\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\n * order to authenticate the request.  If authentication is successful, the user\n * will be logged in and populated at `req.user` and a session will be\n * established by default.  If authentication fails, an unauthorized response\n * will be sent.\n *\n * Options:\n *   - `session`          Save login state in session, defaults to _true_\n *   - `successRedirect`  After successful login, redirect to given URL\n *   - `failureRedirect`  After failed login, redirect to given URL\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\n *\n * An optional `callback` can be supplied to allow the application to overrride\n * the default manner in which authentication attempts are handled.  The\n * callback has the following signature, where `user` will be set to the\n * authenticated user on a successful authentication attempt, or `false`\n * otherwise.  An optional `info` argument will be passed, containing additional\n * details provided by the strategy's verify callback.\n *\n *     app.get('/protected', function(req, res, next) {\n *       passport.authenticate('local', function(err, user, info) {\n *         if (err) { return next(err) }\n *         if (!user) { return res.redirect('/signin') }\n *         res.redirect('/account');\n *       })(req, res, next);\n *     });\n *\n * Note that if a callback is supplied, it becomes the application's\n * responsibility to log-in the user, establish a session, and otherwise perform\n * the desired operations.\n *\n * Examples:\n *\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\n *\n *     passport.authenticate('basic', { session: false });\n *\n *     passport.authenticate('twitter');\n *\n * @param {String} name\n * @param {Object} options\n * @param {Function} callback\n * @return {Function}\n * @api public\n */\nmodule.exports = function authenticate(name, options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  \n  // Cast `name` to an array, allowing authentication to pass through a chain of\n  // strategies.  The first strategy to succeed, redirect, or error will halt\n  // the chain.  Authentication failures will proceed through each strategy in\n  // series, ultimately failing if all strategies fail.\n  //\n  // This is typically used on API endpoints to allow clients to authenticate\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\n  // It is not feasible to construct a chain of multiple strategies that involve\n  // redirection (for example both Facebook and Twitter), since the first one to\n  // redirect will halt the chain.\n  if (!Array.isArray(name)) {\n    name = [ name ];\n  }\n  \n  return function authenticate(req, res, next) {\n    var passport = this;\n    \n    // accumulator for failures from each strategy in the chain\n    var failures = [];\n    \n    function allFailed() {\n      if (callback) {\n        if (failures.length == 1) {\n          return callback(null, false, failures[0].challenge, failures[0].status);\n        } else {\n          var challenges = failures.map(function(f) { return f.challenge; });\n          var statuses = failures.map(function(f) { return f.status; })\n          return callback(null, false, challenges, statuses);\n        }\n      }\n      \n      // Strategies are ordered by priority.  For the purpose of flashing a\n      // message, the first failure will be displayed.\n      var failure = failures[0] || {}\n        , challenge = failure.challenge || {};\n    \n      if (options.failureFlash) {\n        var flash = options.failureFlash;\n        if (typeof flash == 'string') {\n          flash = { type: 'error', message: flash };\n        }\n        flash.type = flash.type || 'error';\n      \n        var type = flash.type || challenge.type || 'error';\n        var msg = flash.message || challenge.message || challenge;\n        if (typeof msg == 'string') {\n          req.flash(type, msg);\n        }\n      }\n      if (options.failureMessage) {\n        var msg = options.failureMessage;\n        if (typeof msg == 'boolean') {\n          msg = challenge.message || challenge;\n        }\n        if (typeof msg == 'string') {\n          req.session.messages = req.session.messages || [];\n          req.session.messages.push(msg);\n        }\n      }\n      if (options.failureRedirect) {\n        return res.redirect(options.failureRedirect);\n      }\n    \n      // When failure handling is not delegated to the application, the default\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\n      // header will be set according to the strategies in use (see\n      // actions#fail).  If multiple strategies failed, each of their challenges\n      // will be included in the response.\n      var rchallenge = []\n        , rstatus;\n      \n      for (var j = 0, len = failures.length; j < len; j++) {\n        var failure = failures[j]\n          , challenge = failure.challenge || {}\n          , status = failure.status;\n        if (typeof challenge == 'number') {\n          status = challenge;\n          challenge = null;\n        }\n          \n        rstatus = rstatus || status;\n        if (typeof challenge == 'string') {\n          rchallenge.push(challenge)\n        }\n      }\n    \n      res.statusCode = rstatus || 401;\n      if (rchallenge.length) {\n        res.setHeader('WWW-Authenticate', rchallenge);\n      }\n      res.end('Unauthorized');\n    }\n    \n    (function attempt(i) {\n      var delegate = {};\n      delegate.success = function(user, info) {\n        if (callback) {\n          return callback(null, user, info);\n        }\n      \n        info = info || {}\n      \n        if (options.successFlash) {\n          var flash = options.successFlash;\n          if (typeof flash == 'string') {\n            flash = { type: 'success', message: flash };\n          }\n          flash.type = flash.type || 'success';\n        \n          var type = flash.type || info.type || 'success';\n          var msg = flash.message || info.message || info;\n          if (typeof msg == 'string') {\n            req.flash(type, msg);\n          }\n        }\n        if (options.successMessage) {\n          var msg = options.successMessage;\n          if (typeof msg == 'boolean') {\n            msg = info.message || info;\n          }\n          if (typeof msg == 'string') {\n            req.session.messages = req.session.messages || [];\n            req.session.messages.push(msg);\n          }\n        }\n        if (options.assignProperty) {\n          req[options.assignProperty] = user;\n          return next();\n        }\n      \n        req.logIn(user, options, function(err) {\n          if (err) { return next(err); }\n          if (options.authInfo || options.authInfo === undefined) {\n            passport.transformAuthInfo(info, function(err, tinfo) {\n              if (err) { return next(err); }\n              req.authInfo = tinfo;\n              complete();\n            });\n          } else {\n            complete();\n          }\n        \n          function complete() {\n            if (options.successReturnToOrRedirect) {\n              var url = options.successReturnToOrRedirect;\n              if (req.session && req.session.returnTo) {\n                url = req.session.returnTo;\n                delete req.session.returnTo;\n              }\n              return res.redirect(url);\n            }\n            if (options.successRedirect) {\n              return res.redirect(options.successRedirect);\n            }\n            next();\n          }\n        });\n      }\n      delegate.fail = function(challenge, status) {\n        // push this failure into the accumulator and attempt authentication\n        // using the next strategy\n        failures.push({ challenge: challenge, status: status });\n        attempt(i + 1);\n      }\n    \n      var layer = name[i];\n      // If no more strategies exist in the chain, authentication has failed.\n      if (!layer) { return allFailed(); }\n    \n      // Get the strategy, which will be used as prototype from which to create\n      // a new instance.  Action functions will then be bound to the strategy\n      // within the context of the HTTP request/response pair.\n      var prototype = passport._strategy(layer);\n      if (!prototype) { return next(new Error('no strategy registered under name: ' + layer)); }\n    \n      var strategy = Object.create(prototype);\n      var context = new Context(delegate, req, res, next);\n      augment(strategy, actions, context);\n    \n      strategy.authenticate(req, options);\n    })(0); // attempt\n  }\n}\n\n\nfunction augment(strategy, actions, ctx) {\n  for (var method in actions) {\n    strategy[method] = actions[method].bind(ctx);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}